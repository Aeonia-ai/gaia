### KB Experience Endpoints and State Logic: An Architectural Deep Dive

---

**ðŸ“Š Note on Metrics**: Any performance numbers, latency projections, or cost estimates mentioned in this document are **illustrative examples** for architectural discussion. They are NOT based on actual measurements or testing. Actual system performance depends on LLM provider response times, network conditions, hardware specifications, and usage patterns. Treat all metrics as directional guidance for understanding system behavior, not as benchmarks or guarantees.

---

The Aeonia Knowledge Base (KB) system orchestrates interactive game experiences through a specialized set of API endpoints and a robust, file-system-based state management system. This architecture is designed to support dynamic, LLM-driven narratives and interactions, accommodating both shared (multiplayer) and isolated (single-player) experience models.

**1. Experience Endpoints (`app/services/kb/experience_endpoints.py`):**

This FastAPI router exposes the primary interface for client-side interaction with game experiences.

*   **`/experience/interact` (POST): The Core Interaction Endpoint**
    *   **Purpose:** This is the central hub for player commands and actions within an experience. It replaces traditional hardcoded game commands with a flexible, markdown-driven approach.
    *   **Request (`InteractRequest`):** Takes a `message` (player's natural language input), an optional `experience` ID, and a `force_experience_selection` flag.
    *   **Flow:**
        1.  **User Identification:** Extracts `user_id` from authentication.
        2.  **Experience Selection:**
            *   First, it attempts to detect an explicit experience selection within the `message` (e.g., "play Wylding Woods").
            *   If not explicit, it determines the current experience from the player's profile or prompts the user to select one if none is active.
        3.  **Player Bootstrapping:** If a player is new to an experience, the `UnifiedStateManager` initializes their `player_view` based on the experience's configuration.
        4.  **State Loading:** Retrieves the current `player_view` and `world_state`. The nature of `world_state` depends on the experience's `state.model` (shared or isolated).
        5.  **Command Detection (`_detect_command_type`):**
            *   Discovers available commands by scanning `game-logic/` and `admin-logic/` markdown files within the experience's directory.
            *   Uses an LLM (Claude Haiku, low temperature) to interpret the player's natural language `message` and map it to a specific markdown command (e.g., "look", "collect", "@reset-experience"). It also handles direct admin commands (prefixed with `@`).
        6.  **Markdown Logic Execution (`_execute_markdown_command` - Two-Pass LLM):** This is the core game logic processing.
            *   **Pass 1 (Logic - Claude Sonnet, low temperature):** The LLM interprets the markdown instructions for the detected command, using the current `player_view` and `world_state` as context. It deterministically generates a JSON object containing `success`, `state_updates` (if any), `available_actions`, and `metadata`. **Crucially, this pass focuses solely on structured data and does NOT generate narrative.**
            *   **Pass 2 (Narrative - Claude Sonnet, higher temperature):** The LLM takes the JSON outcome from Pass 1 and the original markdown instructions to generate a creative, engaging narrative response for the player.
        7.  **State Application (`_apply_state_updates`):** Any `state_updates` generated by Pass 1 are applied to the `world_state` and/or `player_view` via the `UnifiedStateManager`. This includes handling special operations like `$append` and `$remove` for lists.
        8.  **Response (`InteractResponse`):** Returns the generated narrative, the active experience, any state updates, suggested `available_actions`, and diagnostic `metadata`.

*   **`/experience/list` (GET):**
    *   **Purpose:** Provides a list of all available experiences, including their `id`, `name`, `version`, `description`, `state_model`, and `capabilities`.
    *   **Mechanism:** Queries the `UnifiedStateManager` to discover experiences by scanning `config.json` files in `kb_root/experiences/`.

*   **`/experience/info/{experience_id}` (GET):**
    *   **Purpose:** Retrieves detailed metadata for a specific experience.
    *   **Mechanism:** Uses the `UnifiedStateManager` to load and return the experience's configuration.

### 2. Unified State Manager (`app/services/kb/unified_state_manager.py`):

This class is the central authority for managing the persistent state of all experiences and players. It abstracts away the file system interactions and ensures data integrity.

*   **Configuration Management:**
    *   Loads, validates, and caches `config.json` files for each experience (e.g., `kb_root/experiences/{exp}/config.json`).
    *   `config.json` defines critical parameters:
        *   `state.model`: `"shared"` (multiplayer) or `"isolated"` (single-player).
        *   `state.coordination`: `locking_enabled`, `lock_timeout_ms`, `optimistic_versioning`.
        *   `bootstrap`: `player_starting_location`, `player_starting_inventory`, `world_template_path`.
        *   `content`: Paths to `game_logic_path`, `state_path`.
*   **World State Management:**
    *   **Shared Model:** The `world_state` resides in a single `world.json` file (`kb_root/experiences/{exp}/state/world.json`). Updates are protected by **file locking (`fcntl.flock`)** to prevent race conditions during concurrent writes, along with optimistic versioning (`_version` metadata).
    *   **Isolated Model:** Each player receives their own copy of the `world_state`, which is embedded within their `player_view.json` file. No explicit locking is needed for world state in this model, as each player has a unique file.
    *   **Real-time Updates:** All state changes are published to NATS for real-time client synchronization. This achieves **projected sub-100ms perceived latency** (based on NATS pub/sub architecture) by sending visual updates immediately while narrative completes in background.

    **Event Order Guarantee**: `world_update` SSE events are prioritized over `content` events to ensure clients see visual changes before reading the narrative explanation. This prevents the jarring experience of reading "you see a bottle on the shelf" while the bottle is already disappearing from the 3D scene.

    See [NATS-Based Real-Time World Updates: Implementation Analysis](./nats-world-updates-implementation-analysis.md) for complete implementation details and latency projections.
    *   **`_merge_updates`:** A sophisticated deep-merge function that applies updates to JSON state objects. It supports special operations like `$append` (to add items to a list) and `$remove` (to remove items from a list by ID), enabling granular state manipulation.
*   **Player View Management:**
    *   Each player has a dedicated `view.json` file per experience (`kb_root/players/{user_id}/{exp}/view.json`).
    *   For **shared experiences**, the `player_view` stores player-specific data (e.g., current location, inventory references, personal progress) that is not part of the shared `world_state`.
    *   For **isolated experiences**, the `player_view` *is* the player's entire world state.
*   **Player Profile Management:**
    *   A global `profile.json` (`kb_root/players/{user_id}/profile.json`) stores cross-experience player data, most notably the `current_experience` and global statistics.
    *   `set_current_experience` updates this profile, ensuring the system remembers the player's active experience across sessions.
*   **Bootstrapping:**
    *   `bootstrap_player` initializes a new player's state. For shared experiences, it creates a minimal `player_view`. For isolated experiences, it copies the `world.template.json` (from `kb_root/experiences/{exp}/state/world.template.json`) to the player's `view.json`.
*   **Reset Operations:**
    *   `reset_experience` provides powerful tools for developers to reset an experience's state. It supports `full` (restore world + delete all player views), `world_only`, and `players_only` resets.
    *   Includes functionality to create timestamped backups of `world.json` before performing destructive resets.

**3. Markdown Game Logic (`kb_root/experiences/{exp}/game-logic/*.md` & `admin-logic/*.md`):**

*   These markdown files are the "source code" for game mechanics. Each file defines a specific command (e.g., `look.md`, `collect.md`, `@reset-experience.md`).
*   They are structured with sections like "Intent Detection," "Input Parameters," "State Access," "Execution Logic," "State Updates," and "Response Format."
*   The LLM (during the two-pass execution) reads and interprets these sections to understand how to process a player's command, modify state, and generate a narrative.
*   Frontmatter within these markdown files specifies the `command` name, `aliases` (synonyms), and whether the command `requires_admin` permissions.

**4. Testing Experience Changes (`docs/experiences/testing-experience-changes.md`):**

This documentation highlights the developer workflow for iterating on experience logic.

*   **Hot-Reloading:** Emphasizes that changes to markdown logic files and world state JSONs are immediately reflected without service restarts, facilitating rapid development.
*   **API-Driven Testing:** Recommends using Python scripts to directly interact with the `/experience/interact` endpoint, simulating player input.
*   **Robust Validation:** Stresses the importance of:
    *   Using unique `user_id`s for testing to prevent state pollution.
    *   Thoroughly inspecting the `state_updates` returned by the API for correct paths and operations.
    *   Directly verifying the `world.json` and `player_view.json` files on the file system (e.g., using `jq`) to confirm that state changes were persisted as expected.
*   **Troubleshooting:** Provides guidance on common issues like LLM timeouts and incorrect player location.

---

## Latency Optimization Strategies

The KB service's two-pass LLM execution provides excellent separation of logic from narrative, but introduces latency challenges for real-time experiences (VR/AR). Here are optimization strategies based on architectural analysis:

### **Projected Latency Profile** *(architectural estimate)*

```
User: "take bottle"
  â†“ ~1.5s - Pass 1 (Logic with Claude Sonnet, temp=0.2)
  â†“ ~2.0s - Pass 2 (Narrative with Claude Sonnet, temp=0.7)
  â†“ ~3.5s TOTAL (projected based on typical LLM API response times)
Response arrives

**Note**: These are projected estimates based on typical LLM provider response
times and network conditions. Actual latency will vary significantly with API
variability, prompt complexity, and geographic distance.
```

**Design Target**: <1s actual latency, <100ms perceived latency *(aspirational)*

### **Strategy 1: NATS World Updates** (Highest Impact)

**Projected Impact**: Perceived latency multi-second â†’ sub-100ms *(architecture-based)*

By publishing state changes to NATS immediately after `_apply_state_updates`,
clients receive visual updates before the narrative completes:

```
User: "take bottle"
  â†“ ~0.1s - world_update SSE event (bottle disappears visually)
           Based on NATS pub/sub architecture: low-latency messaging
  â†“ ~3.4s - Narrative SSE event ("You pick up the bottle...")
Perceived latency: ~100ms (feels instant!)

**Important**: This timeline is a projection based on NATS pub/sub
architecture patterns, not measured results. Network conditions and
client rendering performance affect real-world delivery times.
```

See [NATS World Updates Analysis](./nats-world-updates-implementation-analysis.md)

### **Strategy 2: Tiered LLM Selection**

**Projected Impact**: Actual latency ~3.5s â†’ ~2.0s (for simple commands) *(estimate)*

Not all commands require Claude Sonnet's reasoning power. Projected latencies
based on typical LLM provider API response times:

| Command Complexity | Model Strategy | Projected Latency* |
|-------------------|----------------|-------------------|
| **Simple** (look, inventory, help) | Haiku single-pass | ~0.8s |
| **Medium** (collect, talk) | Haiku (logic) + Sonnet (narrative) | ~1.5s |
| **Complex** (solve puzzle, negotiate) | Sonnet + Sonnet | ~3.5s |

*Projected based on typical API response times. Actual varies with load and provider.

**Implementation Approach**:
```python
async def _execute_markdown_command(cmd: str, ...):
    if cmd in SIMPLE_COMMANDS:
        # Single pass with Haiku
        return await haiku.generate_structured(
            prompt=markdown_logic,
            response_format={"logic": dict, "narrative": str}
        )
    elif cmd in COMPLEX_COMMANDS:
        # Two-pass with Sonnet
        logic = await sonnet.generate(...)
        narrative = await sonnet.generate(...)
        return logic, narrative
    else:
        # Hybrid: Haiku logic, Sonnet narrative
        logic = await haiku.generate(...)
        narrative = await sonnet.generate(...)
        return logic, narrative
```

### **Strategy 3: Response Streaming**

**Impact**: Reduces time-to-first-token

Instead of waiting for complete narrative, stream chunks as they arrive:

```python
# Pass 2: Stream narrative chunks
async for chunk in sonnet.stream_completion(...):
    yield {"type": "content", "content": chunk}
```

**Projected User Experience**:
- ~0.1s: Visual update (bottle disappears)
- ~0.5s: First words appear ("You carefully...")
- ~2.0s: Full narrative complete
- Feels responsive throughout!

### **Validation Approach**

To measure actual performance in your deployment:

```bash
# Client-side latency measurement
{"type": "world_update", "server_timestamp_ms": 1698765432100}

const latency = Date.now() - event.server_timestamp_ms;
console.log(`Actual delivery latency: ${latency}ms`);
```

**Recommendation**: Establish baseline metrics in your specific environment
before optimizing. Projected numbers provide directional guidance, but your
mileage will vary based on deployment specifics.

---

**Conclusion:**

The KB's experience endpoints and state logic represent a sophisticated, distributed architecture for LLM-driven interactive experiences. By separating symbolic server authority from client-side physical resolution, leveraging markdown for flexible game logic, and employing a robust file-system-based state manager with concurrency controls, the system achieves a balance of flexibility, scalability, and narrative depth. This design allows for rapid iteration on game content while maintaining a consistent and persistent world state.

---

## Verification Status

**Verified By:** Gemini
**Date:** 2025-11-12

This document provides a deep dive into the KB experience endpoints and state logic. The verification confirms that the claims made in this document are accurate and reflect the current state of the codebase.

-   **âœ… Experience Endpoints (`app/services/kb/experience_endpoints.py`):** **VERIFIED**.
    -   **Evidence:** The `/experience/interact` endpoint is the core interaction point, and the `/experience/list` and `/experience/info/{experience_id}` endpoints function as described. The `interact_with_experience` function correctly orchestrates user identification, experience selection, bootstrapping, and delegation to the command processor.

-   **âœ… Unified State Manager (`app/services/kb/unified_state_manager.py`):** **VERIFIED**.
    -   **Evidence:** The `UnifiedStateManager` class correctly manages `config.json` files, handles shared and isolated state models with file locking, publishes to NATS, supports `$append` and `$remove` via `_merge_updates`, and provides the described player profile, bootstrapping, and reset functionalities.

-   **âœ… Markdown Game Logic:** **VERIFIED**.
    -   **Evidence:** The `_load_command_markdown` and `_discover_available_commands` methods in `app/services/kb/kb_agent.py` confirm that game logic is loaded from markdown files in the `game-logic/` and `admin-logic/` directories and that YAML frontmatter is used for command definition.

-   **âœ… Two-Pass LLM Architecture:** **VERIFIED**.
    -   **Evidence:** The `_execute_markdown_command` method in `app/services/kb/kb_agent.py` implements the described two-pass system for logic and narrative generation.

**Conclusion:** This document is a highly accurate and reliable description of the implemented architecture for the KB experience endpoints and state logic. All key claims have been verified.

---

## Verification Status

**Verified By:** Gemini
**Date:** 2025-11-12

This document provides a deep dive into the KB experience endpoints and state logic. The verification confirms that the claims made in this document are accurate and reflect the current state of the codebase.

-   **âœ… Experience Endpoints (`app/services/kb/experience_endpoints.py`):** **VERIFIED**.
    -   **Evidence:** The `/experience/interact` endpoint is the core interaction point, and the `/experience/list` and `/experience/info/{experience_id}` endpoints function as described. The `interact_with_experience` function correctly orchestrates user identification, experience selection, bootstrapping, and delegation to the command processor.

-   **âœ… Unified State Manager (`app/services/kb/unified_state_manager.py`):** **VERIFIED**.
    -   **Evidence:** The `UnifiedStateManager` class correctly manages `config.json` files, handles shared and isolated state models with file locking, publishes to NATS, supports `$append` and `$remove` via `_merge_updates`, and provides the described player profile, bootstrapping, and reset functionalities.

-   **âœ… Markdown Game Logic:** **VERIFIED**.
    -   **Evidence:** The `_load_command_markdown` and `_discover_available_commands` methods in `app/services/kb/kb_agent.py` confirm that game logic is loaded from markdown files in the `game-logic/` and `admin-logic/` directories and that YAML frontmatter is used for command definition.

-   **âœ… Two-Pass LLM Architecture:** **VERIFIED**.
    -   **Evidence:** The `_execute_markdown_command` method in `app/services/kb/kb_agent.py` implements the described two-pass system for logic and narrative generation.

**Conclusion:** This document is a highly accurate and reliable description of the implemented architecture for the KB experience endpoints and state logic. All key claims have been verified.
